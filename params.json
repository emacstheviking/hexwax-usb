{"name":"Hexwax-usb","tagline":"A Haskell USB interface to the Hexwax Expand-IO USB chip","body":"# Hexwax ExpandIO USB Application\r\n\r\nThis is some Haskell code that requires the use of \"libusb\". You should first build and install it on your platform. I can ensure you this works on Linux and OS X (see later) but I have never tried it on Windows as I don't use it.\r\n\r\nHaving built and installed libusb, install the packages `bindings-libusb` and `usb` and you are good to go with your Haskell installation.\r\n\r\n\r\n# The Code…\r\n\r\n…is proof of concept and probably not as neat as it could be but hell, it works and that's all I wanted or needed it to do. Currently it has application code to control a coil-winder and a temperature controlled hand-crocheted Owl shaped tea cosy. Because I can.\r\n\r\n\r\n\r\n## OSX -- Nightmare!\r\n\r\nWhen I first tried to get this to run under OS X, I had to learn the hard way that the second you plug the device into the machine the kernel jumps in and steals it and assigns it a default handler. This initially caused me problems as the OS X version of \"libusb\" doesn't actually unbind kernel handlers when asked to do so. To cut a long and painful story short I sorted it with some help from the Apple USB mailing list. Read on...\r\n\r\n\r\n# Granting user permissions using \"udev\"\r\n\r\nWhen you plug the expandIO-USB device into your Linux machine, it\r\nshould appear in the list of USB devices if you use the \"lsusb\"\r\ncommand like this: (it's the empty line!)\r\n\r\n\r\n    Bus 002 Device 002: ID 046d:c31c Logitech, Inc. Keyboard K120 for Business\r\n    Bus 003 Device 002: ID 046d:c050 Logitech, Inc. RX 250 Optical Mouse\r\n    Bus 004 Device 002: ID 0a5c:4500 Broadcom Corp. BCM2046B1 USB 2.0 Hub (part of BCM2046 Bluetooth)\r\n    Bus 005 Device 002: ID 0b40:0132\r\n    Bus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub\r\n    Bus 002 Device 001: ID 1d6b:0001 Linux Foundation 1.1 root hub\r\n    Bus 003 Device 001: ID 1d6b:0001 Linux Foundation 1.1 root hub\r\n    Bus 004 Device 001: ID 1d6b:0001 Linux Foundation 1.1 root hub\r\n    Bus 005 Device 001: ID 1d6b:0001 Linux Foundation 1.1 root hub\r\n    Bus 004 Device 003: ID 0a5c:4502 Broadcom Corp. Keyboard (Boot Interface Subclass)\r\n    Bus 004 Device 004: ID 0a5c:4503 Broadcom Corp. Mouse (Boot Interface Subclass)\r\n    Bus 004 Device 005: ID 050d:016a Belkin Components Bluetooth Mini Dongle\r\n\r\n\r\nHowever, that doesn't mean that the device is accessible, indeed at\r\nthis point it would require you to be \"root\" in order to be able to\r\nsend commands to it; this is because it hasn't yet been configured\r\nproperly. It's simple if you follow these steps but please bear in\r\nmind that the Linux distro used was \"Mint/14\", YMMV.\r\n\r\n\r\n## Identifying the device\r\n\r\nThe simplest way to get the information that we need is to open a\r\nterminal window and then issue this command:\r\n\r\n    tail -f /var/log/syslog\r\n\r\n\r\nThen plug in your development board / rig / whatever and then watch\r\nthe output from \"tail\", you should see something that looks almost\r\nidentical to this, the product and vendor identification numbers\r\nshould be \"0xb30:0132\" whatever Linux distro you use as that is how\r\nthe PIC device is programmed at the factory! Here is the output:\r\n\r\n    kernel: [ 1961.104065] usb 5-1: >USB disconnect, device number 3\r\n    kernel: [ 1964.520027] usb 5-1: >new full-speed USB device number 4 using uhci_hcd\r\n    kernel: [ 1964.764051] usb 5-1: >New USB device found, idVendor=0b40, idProduct=0132\r\n    kernel: [ 1964.764058] usb 5-1: >New USB device strings: Mfr=2, Product=1, SerialNumber=3\r\n    kernel: [ 1964.764063] usb 5-1: >Product: expandIO-USB\r\n    kernel: [ 1964.764067] usb 5-1: >Manufacturer: Firmware Factory Ltd\r\n    kernel: [ 1964.764070] usb 5-1: >SerialNumber: 21436587-2455-011F080C7-02AF8598B518\r\n    mtp-probe: checking bus 5, device 4: \"/sys/devices/pci0000:00/0000:00:1d.3/usb5/5-1\"\r\n    mtp-probe: bus: 5, device: 4 was not an MTP device\r\n    kernel: [ 1964.777332] hid-generic 0003:0B40:0132.0008: >hiddev0,hidraw5: USB HID v1.11 Device [Firmware Factory Ltd expandIO-USB] on usb-0000\r\n\r\n\r\n## Getting the path to the USB device\r\n\r\nSo far so good. The piece of information that we want is the path to\r\nthe device as seen by the system, in this case it is:\r\n\r\n    /sys/devices/pci0000:00/0000:00:1d.3/usb5/5-1\r\n\r\n\r\n## Getting the key names and device identifiers\r\n\r\nUsing that piece of information we can now use the \"udevadm\" program\r\nto dump everything it knows about our device:\r\n\r\n    udevadm info -a -p /sys/devices/pci0000:00/0000:00:1d.3/usb5/5-1\r\n\r\nThis will produce a monster load of output! Don't be put off, we\r\nnearly have what we want to be able to write a custom \"udev\" rule so\r\nthat we don't have to run as root all the time. Here it is, but\r\ntruncated so that we don't get swamped with too much info:\r\n\r\n  looking at device '/devices/pci0000:00/0000:00:1d.3/usb5/5-1':\r\n    KERNEL==\"5-1\"\r\n    SUBSYSTEM==\"usb\"\r\n    DRIVER==\"usb\"\r\n    ATTR{idVendor}==\"0b40\"\r\n    ATTR{serial}==\"21436587-2455-011F080C7-02AF8598B518\"\r\n    ATTR{version}==\" 2.00\"\r\n    ATTR{urbnum}==\"20\"\r\n    ATTR{manufacturer}==\"Firmware Factory Ltd\"\r\n    ATTR{removable}==\"unknown\"\r\n    ATTR{idProduct}==\"0132\"\r\n    ATTR{bDeviceClass}==\"00\"\r\n    ATTR{product}==\"expandIO-USB\"\r\n\r\n\r\nWhat we need is JUST the \"idVendor\" and \"idProduct\" values *which we\r\nalready knew* but the reason for the above step is to get the system\r\nto tell us how it names the keys, it has been known to vary between\r\n\"udev\" versions so getting the \"udevadm\" to tell us is getting it\r\nstraight from the source, we then only have to use the same key names\r\nin our new rule file to guarantee success. Here is the filename you\r\nmust create as root:\r\n\r\n    /etc/udev/rules.d/hexwax-expandio.rules\r\n\r\nHere is what should go into it:\r\n\r\n    # Hexwax expandIO-USB chip, unmodified product and vendor id assumed.\r\n    SUBSYSTEM==\"usb\", ACTION==\"add\", ATTR{idVendor}==\"0b40\",\r\n        ATTR{idProduct}==\"0132\", GROUP=\"users\", MODE=\"0666\"\r\n\r\n(Broken into two lines for clarity but please make sure that you enter\r\nit as *a single line* and ensure that you have used '==' not '=' if\r\nyou manually type it).\r\n\r\nWhat this says to the system is that the next time you plug in your\r\ndevice, it is to make it accessibhle to the group \"users\" (that's you)\r\nand that it will have full read and write permissions. Once you have\r\nsaved this file, \"udev\" will notice the change to the folder and\r\nautomatically take the new rule and process it.\r\n\r\nIf you have followed all of the above steps correctly then you should\r\nbe able to develop programs for your device and not be root.\r\n\r\n\r\n# OS X and HID Devices\r\n\r\nWhen you plug your device into OS X, the kernel will grab it. That's\r\nnot good and means for example that you won't be able to use \"libusb\"\r\nto write code to play with it. In order to prevent that from\r\nhappening, you will need to install the supplied \"codeless kext\" by\r\nfollowing these steps, assuming that you are in the terminal window\r\nand currently in the same folder as this README file:\r\n\r\n    $ sudo cp -r HexwaxShield.kext /System/Library/Extensions/.\r\n    $ sudo chown -R root:wheel /System/Library/Extensions/HexwaxShield.kext\r\n    $ sudo kextload -vt /System/Library/Extensions/HexwaxShield.kext/\r\n    Notice: -print-diagnostics (-t) ignored; use kextutil(8) to test kexts.\r\n    Requesting load of /System/Library/Extensions/HexwaxShield.kext.\r\n    /System/Library/Extensions/HexwaxShield.kext loaded successfully (or already loaded).\r\n\r\nNow when you plug the device in, the kernel will no longer\r\nautomatically grab it and wrap it, instead it will be left alone which\r\nmeans that your code can talk to it instead. If you don't install the\r\nextension then you will have to use IOKit to manage it. If that's what\r\nyou want then that's fine if you developing a product specifically for\r\nthe Mac market but if you want to maintain cross-platform code using\r\nlibusb then you will need to do the above.\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}